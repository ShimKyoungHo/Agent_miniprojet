# agents/company_analysis_agent.py

from typing import Dict, Any, Optional, List
import asyncio
import os
from datetime import datetime
from tavily import TavilyClient
from .base_agent import BaseAgent


class CompanyAnalysisAgent(BaseAgent):
    """Í∏∞ÏóÖ Î∂ÑÏÑù Agent - Tavily Ïõπ Í≤ÄÏÉâ ÌôúÏö© (ÎèôÏ†Å Í∏∞ÏóÖ Î∞úÍµ¥)"""
    
    def __init__(self, llm=None, config: Optional[Dict] = None):
        super().__init__("company_analysis", llm, config)
        
        # ÎèôÏ†Å Î∞úÍµ¥ÏùÑ ÏÇ¨Ïö©Ìï†ÏßÄ Ïó¨Î∂Ä
        self.use_dynamic_discovery = config.get('use_dynamic_discovery', True) if config else True
        
        # FallbackÏö© Í∏∞Î≥∏ Í∏∞ÏóÖ Î™©Î°ù (ÎèôÏ†Å Î∞úÍµ¥ Ïã§Ìå® Ïãú)
        self.fallback_companies = config.get('target_companies', [
            'Tesla', 'BYD', 'Volkswagen', 'Hyundai', 'GM', 
            'Ford', 'Rivian', 'NIO', 'XPeng', 'Stellantis'
        ]) if config else ['Tesla', 'BYD', 'Volkswagen', 'Hyundai', 'GM']
        
        self.max_companies = config.get('max_companies', 10) if config else 10
        
        # Tavily ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
        tavily_api_key = os.getenv('TAVILY_API_KEY')
        if tavily_api_key:
            self.tavily_client = TavilyClient(api_key=tavily_api_key)
            self.logger.info("Tavily ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        else:
            self.tavily_client = None
            self.logger.warning("TAVILY_API_KEYÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Í≤ÄÏÉâ Í∏∞Îä•Ïù¥ Ï†úÌïúÎê©ÎãàÎã§.")
    
    async def process(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Í∏∞ÏóÖ Î∂ÑÏÑù Î©îÏù∏ ÌîÑÎ°úÏÑ∏Ïä§"""
        self.logger.info("Í∏∞ÏóÖ Î∂ÑÏÑù ÏãúÏûë...")
        
        try:
            # 1Îã®Í≥Ñ: ÏÉÅÏúÑ Ï†ÑÍ∏∞Ï∞® Í∏∞ÏóÖ Î∞úÍµ¥
            if self.use_dynamic_discovery and self.tavily_client:
                self.logger.info("üîç Ï†ÑÍ∏∞Ï∞® ÏãúÏû• ÏÉÅÏúÑ Í∏∞ÏóÖ Î∞úÍµ¥ Ï§ë...")
                companies = await self._discover_top_companies()
                
                if not companies:
                    self.logger.warning("ÎèôÏ†Å Î∞úÍµ¥ Ïã§Ìå®. Fallback Í∏∞ÏóÖ Î™©Î°ù ÏÇ¨Ïö©")
                    companies = self.fallback_companies[:self.max_companies]
            else:
                companies = self.fallback_companies[:self.max_companies]
            
            # ÏÉÅÏúÑ NÍ∞úÎ°ú Ï†úÌïú
            companies = companies[:self.max_companies]
            self.logger.info(f"‚úÖ Î∂ÑÏÑù ÎåÄÏÉÅ Í∏∞ÏóÖ ({len(companies)}Í∞ú): {', '.join(companies)}")
            
            # 2Îã®Í≥Ñ: Î≥ëÎ†¨Î°ú Ïó¨Îü¨ Í∏∞ÏóÖ Î∂ÑÏÑù
            tasks = []
            for company in companies:
                tasks.append(self._analyze_company(company))
            
            company_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # 3Îã®Í≥Ñ: Í≤∞Í≥º ÌÜµÌï© Î∞è ÌïµÏã¨ Í∏∞Ïà† Ï∂îÏ∂ú
            companies_data = {}
            tech_portfolio = {}
            
            for i, company in enumerate(companies):
                if not isinstance(company_results[i], Exception):
                    company_data = company_results[i]
                    companies_data[company] = company_data
                    
                    # ÌïµÏã¨ Í∏∞Ïà† Ï∂îÏ∂ú
                    key_tech = await self._extract_key_technologies(company, company_data)
                    if key_tech:
                        tech_portfolio[company] = key_tech
                else:
                    self.logger.error(f"{company} Î∂ÑÏÑù Ïã§Ìå®: {company_results[i]}")
            
            # 4Îã®Í≥Ñ: ÏÇ∞ÏóÖ Ï†ÑÏ≤¥ Î∂ÑÏÑù
            industry_analysis = await self._analyze_industry_dynamics(companies_data)
            
            # 5Îã®Í≥Ñ: LLMÏùÑ ÌÜµÌïú Ï¢ÖÌï© Î∂ÑÏÑù
            synthesis = None
            if self.llm:
                synthesis = await self._synthesize_company_insights(companies_data, industry_analysis)
            
            # ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            state['company_analysis'] = {
                'companies': companies_data,
                'industry_analysis': industry_analysis,
                'synthesis': synthesis,
                'discovered_companies': companies,  # Î∞úÍµ¥Îêú Í∏∞ÏóÖ Î¶¨Ïä§Ìä∏
                'timestamp': self.get_timestamp()
            }
            state['company_tech_data'] = tech_portfolio  # Í∏∞Ïà† Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨
            
            # Í≤∞Í≥º Ï†ÄÏû•
            self.save_output(state['company_analysis'], 'company_analysis.json')
            self.save_output(tech_portfolio, 'company_tech_portfolio.json')
            
            self.logger.info(f"‚úÖ Í∏∞ÏóÖ Î∂ÑÏÑù ÏôÑÎ£å ({len(companies_data)}Í∞ú Í∏∞ÏóÖ, {len(tech_portfolio)}Í∞ú Í∏∞Ïà† Ìè¨Ìä∏Ìè¥Î¶¨Ïò§)")
            return state
            
        except Exception as e:
            self.logger.error(f"Í∏∞ÏóÖ Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {e}")
            import traceback
            traceback.print_exc()
            state['errors'].append(f"company_analysis: {str(e)}")
            return state
    
    async def _discover_top_companies(self) -> List[str]:
        """Ï†ÑÍ∏∞Ï∞® ÏãúÏû• ÏÉÅÏúÑ Í∏∞ÏóÖ Î∞úÍµ¥"""
        try:
            # Ïó¨Îü¨ Í≤ÄÏÉâ ÏøºÎ¶¨Î°ú Ï¢ÖÌï©Ï†ÅÏúºÎ°ú Ï°∞ÏÇ¨
            queries = [
                "top electric vehicle manufacturers market share 2025",
                "leading EV companies sales volume 2025",
                "largest electric car makers by production 2025"
            ]
            
            all_companies = []
            
            for query in queries:
                search_results = await asyncio.to_thread(
                    self.tavily_client.search,
                    query=query,
                    max_results=5
                )
                
                # Í≤ÄÏÉâ Í≤∞Í≥ºÏóêÏÑú Í∏∞ÏóÖÎ™Ö Ï∂îÏ∂ú
                companies = await self._extract_companies_from_search(
                    search_results.get('results', []),
                    query
                )
                all_companies.extend(companies)
            
            # Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è ÎπàÎèÑÏàú Ï†ïÎ†¨
            company_counts = {}
            for company in all_companies:
                company_counts[company] = company_counts.get(company, 0) + 1
            
            # ÎπàÎèÑÏàúÏúºÎ°ú Ï†ïÎ†¨ (ÎßéÏù¥ Ïñ∏Í∏âÎêú Í∏∞ÏóÖÏù¥ ÏÉÅÏúÑ)
            sorted_companies = sorted(
                company_counts.items(), 
                key=lambda x: x[1], 
                reverse=True
            )
            
            # Í∏∞ÏóÖÎ™ÖÎßå Ï∂îÏ∂ú
            top_companies = [company for company, count in sorted_companies[:self.max_companies]]
            
            self.logger.info(f"Î∞úÍµ¥Îêú ÏÉÅÏúÑ Í∏∞ÏóÖ: {top_companies}")
            
            return top_companies
            
        except Exception as e:
            self.logger.error(f"Í∏∞ÏóÖ Î∞úÍµ¥ Ï§ë Ïò§Î•ò: {e}")
            return []
    
    async def _extract_companies_from_search(self, search_results: List[Dict], query: str) -> List[str]:
        """Í≤ÄÏÉâ Í≤∞Í≥ºÏóêÏÑú Í∏∞ÏóÖÎ™Ö Ï∂îÏ∂ú (LLM ÌôúÏö©)"""
        if not search_results or not self.llm:
            return []
        
        try:
            # Í≤ÄÏÉâ Í≤∞Í≥ºÎ•º ÌÖçÏä§Ìä∏Î°ú Î≥ÄÌôò
            results_text = "\n\n".join([
                f"Ï†úÎ™©: {r.get('title', '')}\nÎÇ¥Ïö©: {r.get('content', '')[:300]}"
                for r in search_results[:5]
            ])
            
            prompt = f"""Îã§Ïùå Í≤ÄÏÉâ Í≤∞Í≥ºÏóêÏÑú Ï†ÑÍ∏∞Ï∞®Î•º ÏÉùÏÇ∞ÌïòÎäî Ï£ºÏöî Í∏∞ÏóÖÎ™ÖÏùÑ Ï∂îÏ∂úÌïòÏÑ∏Ïöî.

Í≤ÄÏÉâ ÏøºÎ¶¨: {query}

Í≤ÄÏÉâ Í≤∞Í≥º:
{results_text}

Ï°∞Í±¥:
1. Ïã§Ï†úÎ°ú Ï†ÑÍ∏∞Ï∞®Î•º ÏÉùÏÇ∞ÌïòÎäî Í∏∞ÏóÖÎßå Ï∂îÏ∂ú
2. Î∏åÎûúÎìúÎ™ÖÏù¥ ÏïÑÎãå Í∏∞ÏóÖÎ™ÖÏúºÎ°ú ÌÜµÏùº (Ïòà: Audi ‚Üí Volkswagen, Chevrolet Bolt ‚Üí GM)
3. ÏòÅÏñ¥ Í∏∞ÏóÖÎ™ÖÏúºÎ°ú ÌëúÍ∏∞
4. Ï§ëÍµ≠ Í∏∞ÏóÖÏùÄ Ï†ïÏãù ÏòÅÏñ¥Î™Ö ÏÇ¨Ïö©

Îã§Ïùå ÌòïÏãùÏùò JSONÏúºÎ°úÎßå ÏùëÎãµÌïòÏÑ∏Ïöî:
{{
  "companies": ["Tesla", "BYD", "Volkswagen", ...]
}}

JSONÎßå Ï∂úÎ†•ÌïòÏÑ∏Ïöî."""
            
            response = await self.llm.ainvoke(prompt)
            content = response.content if hasattr(response, 'content') else str(response)
            
            # JSON ÌååÏã±
            import json
            import re
            
            json_match = re.search(r'\{[^}]+\}', content, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group())
                companies = data.get('companies', [])
                self.logger.info(f"Ï∂îÏ∂úÎêú Í∏∞ÏóÖ ({len(companies)}Í∞ú): {companies}")
                return companies
            else:
                self.logger.warning("Í∏∞ÏóÖÎ™Ö Ï∂îÏ∂ú Ïã§Ìå® - JSON ÌååÏã± Ïò§Î•ò")
                return []
                
        except Exception as e:
            self.logger.error(f"Í∏∞ÏóÖÎ™Ö Ï∂îÏ∂ú Ïò§Î•ò: {e}")
            return []
    
    async def _analyze_company(self, company: str) -> Dict:
        """Í∞úÎ≥Ñ Í∏∞ÏóÖ Î∂ÑÏÑù"""
        self.logger.info(f"  üè¢ {company} Î∂ÑÏÑù Ï§ë...")
        
        if not self.tavily_client:
            return self._get_fallback_company_data(company)
        
        try:
            # Î≥ëÎ†¨Î°ú Ïó¨Îü¨ Ï∏°Î©¥ Ï°∞ÏÇ¨
            tasks = [
                self._search_company_strategy(company),
                self._search_company_production(company),
                self._search_company_technology(company),
                self._search_company_market_position(company),
                self._search_company_news(company)
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            company_data = {
                'name': company,
                'strategy': results[0] if not isinstance(results[0], Exception) else None,
                'production': results[1] if not isinstance(results[1], Exception) else None,
                'technology': results[2] if not isinstance(results[2], Exception) else None,
                'market_position': results[3] if not isinstance(results[3], Exception) else None,
                'news': results[4] if not isinstance(results[4], Exception) else None,
                'analysis_date': datetime.now().isoformat()
            }
            
            # LLM Ï¢ÖÌï© Î∂ÑÏÑù
            if self.llm:
                analysis = await self._analyze_company_comprehensive(company, company_data)
                company_data['llm_analysis'] = analysis
            
            return company_data
            
        except Exception as e:
            self.logger.error(f"{company} Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return self._get_fallback_company_data(company)
    
    async def _search_company_strategy(self, company: str) -> Dict:
        """Í∏∞ÏóÖ Ï†ÑÎûµ Í≤ÄÏÉâ"""
        try:
            query = f"{company} electric vehicle strategy roadmap 2025 2030"
            search_results = await asyncio.to_thread(
                self.tavily_client.search,
                query=query,
                max_results=3
            )
            
            return {
                'query': query,
                'results': search_results.get('results', [])
            }
        except Exception as e:
            self.logger.error(f"{company} Ï†ÑÎûµ Í≤ÄÏÉâ Ïò§Î•ò: {e}")
            return {'error': str(e)}
    
    async def _search_company_production(self, company: str) -> Dict:
        """ÏÉùÏÇ∞ Îä•Î†• Í≤ÄÏÉâ"""
        try:
            query = f"{company} electric vehicle production capacity sales volume 2025"
            search_results = await asyncio.to_thread(
                self.tavily_client.search,
                query=query,
                max_results=3
            )
            
            return {
                'query': query,
                'results': search_results.get('results', [])
            }
        except Exception as e:
            self.logger.error(f"{company} ÏÉùÏÇ∞ Í≤ÄÏÉâ Ïò§Î•ò: {e}")
            return {'error': str(e)}
    
    async def _search_company_technology(self, company: str) -> Dict:
        """Í∏∞Ïà† Í∞úÎ∞ú Í≤ÄÏÉâ"""
        try:
            query = f"{company} electric vehicle battery technology innovation platform 2025"
            search_results = await asyncio.to_thread(
                self.tavily_client.search,
                query=query,
                max_results=4
            )
            
            return {
                'query': query,
                'results': search_results.get('results', [])
            }
        except Exception as e:
            self.logger.error(f"{company} Í∏∞Ïà† Í≤ÄÏÉâ Ïò§Î•ò: {e}")
            return {'error': str(e)}
    
    async def _search_company_market_position(self, company: str) -> Dict:
        """ÏãúÏû• ÏßÄÏúÑ Í≤ÄÏÉâ"""
        try:
            query = f"{company} electric vehicle market share position ranking 2025"
            search_results = await asyncio.to_thread(
                self.tavily_client.search,
                query=query,
                max_results=3
            )
            
            return {
                'query': query,
                'results': search_results.get('results', [])
            }
        except Exception as e:
            self.logger.error(f"{company} ÏãúÏû• ÏßÄÏúÑ Í≤ÄÏÉâ Ïò§Î•ò: {e}")
            return {'error': str(e)}
    
    async def _search_company_news(self, company: str) -> Dict:
        """ÏµúÏã† Îâ¥Ïä§ Í≤ÄÏÉâ"""
        try:
            query = f"{company} electric vehicle news latest developments 2025"
            search_results = await asyncio.to_thread(
                self.tavily_client.search,
                query=query,
                max_results=5
            )
            
            return {
                'query': query,
                'results': search_results.get('results', [])
            }
        except Exception as e:
            self.logger.error(f"{company} Îâ¥Ïä§ Í≤ÄÏÉâ Ïò§Î•ò: {e}")
            return {'error': str(e)}
    
    async def _extract_key_technologies(self, company: str, company_data: Dict) -> Dict:
        """Í∏∞ÏóÖÏùò ÌïµÏã¨ Í∏∞Ïà† Ï∂îÏ∂ú (Tech Analysis AgentÏóê Ï†ÑÎã¨)"""
        if not self.llm:
            return self._extract_basic_technologies(company_data)
        
        try:
            # Í∏∞Ïà† Í¥ÄÎ†® Ï†ïÎ≥¥ ÏàòÏßë
            tech_info = self._extract_key_info(company_data.get('technology', {}))
            strategy_info = self._extract_key_info(company_data.get('strategy', {}))
            
            prompt = f"""{company}Ïùò Ï†ÑÍ∏∞Ï∞® Í¥ÄÎ†® ÌïµÏã¨ Í∏∞Ïà†ÏùÑ Îã§Ïùå Ï†ïÎ≥¥ÏóêÏÑú Ï∂îÏ∂úÌïòÏÑ∏Ïöî:

Í∏∞Ïà† Ï†ïÎ≥¥: {tech_info}
Ï†ÑÎûµ Ï†ïÎ≥¥: {strategy_info}

Îã§Ïùå Ïπ¥ÌÖåÍ≥†Î¶¨Î≥ÑÎ°ú ÌïµÏã¨ Í∏∞Ïà†ÏùÑ Ï∂îÏ∂úÌïòÏÑ∏Ïöî:
1. Î∞∞ÌÑ∞Î¶¨ Í∏∞Ïà† (Battery Technology)
2. Ï∂©Ï†Ñ Í∏∞Ïà† (Charging Technology)
3. Î™®ÌÑ∞/ÌååÏõåÌä∏Î†àÏù∏ (Motor/Powertrain)
4. ÏûêÏú®Ï£ºÌñâ (Autonomous Driving)
5. ÌîåÎû´Ìèº/ÏïÑÌÇ§ÌÖçÏ≤ò (Platform/Architecture)
6. ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ (Software)
7. Í∏∞ÌÉÄ ÌòÅÏã† Í∏∞Ïà† (Other Innovations)

Îã§Ïùå ÌòïÏãùÏùò JSONÏúºÎ°úÎßå ÏùëÎãµÌïòÏÑ∏Ïöî:
{{
  "battery": "Íµ¨Ï≤¥Ï†Å Í∏∞Ïà†Î™Ö Î∞è ÏÑ§Î™Ö",
  "charging": "Íµ¨Ï≤¥Ï†Å Í∏∞Ïà†Î™Ö Î∞è ÏÑ§Î™Ö",
  "motor_powertrain": "Íµ¨Ï≤¥Ï†Å Í∏∞Ïà†Î™Ö Î∞è ÏÑ§Î™Ö",
  "autonomous": "Íµ¨Ï≤¥Ï†Å Í∏∞Ïà†Î™Ö Î∞è ÏÑ§Î™Ö",
  "platform": "Íµ¨Ï≤¥Ï†Å Í∏∞Ïà†Î™Ö Î∞è ÏÑ§Î™Ö",
  "software": "Íµ¨Ï≤¥Ï†Å Í∏∞Ïà†Î™Ö Î∞è ÏÑ§Î™Ö",
  "other": "Í∏∞ÌÉÄ ÌòÅÏã† Í∏∞Ïà†",
  "key_differentiators": ["Ï∞®Î≥ÑÌôî ÏöîÏÜå 1", "Ï∞®Î≥ÑÌôî ÏöîÏÜå 2", ...]
}}

Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Í∏∞Ïà†Ïù¥ ÏóÜÏúºÎ©¥ "N/A"Î°ú ÌëúÏãúÌïòÏÑ∏Ïöî.
JSONÎßå Ï∂úÎ†•ÌïòÏÑ∏Ïöî."""
            
            response = await self.llm.ainvoke(prompt)
            content = response.content if hasattr(response, 'content') else str(response)
            
            # JSON ÌååÏã±
            import json
            import re
            
            json_match = re.search(r'\{.*\}', content, re.DOTALL)
            if json_match:
                tech_data = json.loads(json_match.group())
                self.logger.info(f"{company} ÌïµÏã¨ Í∏∞Ïà† Ï∂îÏ∂ú ÏôÑÎ£å")
                return tech_data
            else:
                self.logger.warning(f"{company} Í∏∞Ïà† Ï∂îÏ∂ú Ïã§Ìå® - JSON ÌååÏã± Ïò§Î•ò")
                return self._extract_basic_technologies(company_data)
                
        except Exception as e:
            self.logger.error(f"{company} Í∏∞Ïà† Ï∂îÏ∂ú Ïò§Î•ò: {e}")
            return self._extract_basic_technologies(company_data)
    
    def _extract_basic_technologies(self, company_data: Dict) -> Dict:
        """Í∏∞Î≥∏Ï†ÅÏù∏ Í∏∞Ïà† Ï†ïÎ≥¥ Ï∂îÏ∂ú (LLM ÏóÜÏùÑ Îïå)"""
        tech_data = company_data.get('technology', {})
        
        if tech_data and 'results' in tech_data:
            results = tech_data['results'][:2]
            tech_summary = " | ".join([
                r.get('content', '')[:100] for r in results if r.get('content')
            ])
            
            return {
                'battery': tech_summary[:200] if tech_summary else 'N/A',
                'charging': 'N/A',
                'motor_powertrain': 'N/A',
                'autonomous': 'N/A',
                'platform': 'N/A',
                'software': 'N/A',
                'other': 'N/A',
                'key_differentiators': ['Í≤ÄÏÉâ Í≤∞Í≥º Í∏∞Î∞ò Ï∂îÏ∂ú']
            }
        
        return {
            'battery': 'N/A',
            'charging': 'N/A',
            'motor_powertrain': 'N/A',
            'autonomous': 'N/A',
            'platform': 'N/A',
            'software': 'N/A',
            'other': 'N/A',
            'key_differentiators': []
        }
    
    async def _analyze_company_comprehensive(self, company: str, data: Dict) -> str:
        """Í∏∞ÏóÖ Îç∞Ïù¥ÌÑ∞ Ï¢ÖÌï© Î∂ÑÏÑù"""
        if not self.llm:
            return "Ï¢ÖÌï© Î∂ÑÏÑù Î∂àÍ∞Ä (LLM ÎØ∏ÏÑ§Ï†ï)"
        
        try:
            # Í≤ÄÏÉâ Í≤∞Í≥ºÏóêÏÑú ÌïµÏã¨ Ï†ïÎ≥¥ Ï∂îÏ∂ú
            strategy_info = self._extract_key_info(data.get('strategy', {}))
            production_info = self._extract_key_info(data.get('production', {}))
            tech_info = self._extract_key_info(data.get('technology', {}))
            market_info = self._extract_key_info(data.get('market_position', {}))
            
            prompt = f"""{company}Ïùò Ï†ÑÍ∏∞Ï∞® ÏÇ¨ÏóÖÏùÑ Îã§Ïùå Ï†ïÎ≥¥Î•º Î∞îÌÉïÏúºÎ°ú Ï¢ÖÌï© Î∂ÑÏÑùÌïòÏÑ∏Ïöî:

Ï†ÑÎûµ: {strategy_info}
ÏÉùÏÇ∞: {production_info}
Í∏∞Ïà†: {tech_info}
ÏãúÏû• ÏßÄÏúÑ: {market_info}

Îã§Ïùå Ìï≠Î™©ÏùÑ Í∞ÑÍ≤∞ÌïòÍ≤å Î∂ÑÏÑùÌï¥Ï£ºÏÑ∏Ïöî:
1. ÏãúÏû• Ìè¨ÏßÄÏÖò Î∞è Ï†êÏú†Ïú® (2-3Î¨∏Ïû•)
2. ÌïµÏã¨ Í≤ΩÏüÅÎ†• (3-4Í∞ú bullet points)
3. ÏÇ¨ÏóÖ Ï†ÑÎûµ Î∞è Ìà¨Ïûê Î∞©Ìñ• (2-3Î¨∏Ïû•)
4. Ï£ºÏöî Î¶¨Ïä§ÌÅ¨ (2-3Î¨∏Ïû•)
5. Ìñ•ÌõÑ Ï†ÑÎßù (2-3Î¨∏Ïû•)

ÌïúÍµ≠Ïñ¥Î°ú ÏûëÏÑ±ÌïòÏÑ∏Ïöî."""
            
            response = await self.llm.ainvoke(prompt)
            return response.content if hasattr(response, 'content') else str(response)
            
        except Exception as e:
            self.logger.error(f"{company} Ï¢ÖÌï© Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return "Î∂ÑÏÑù Ï§ë Ïò§Î•ò Î∞úÏÉù"
    
    def _extract_key_info(self, search_data: Dict) -> str:
        """Í≤ÄÏÉâ Í≤∞Í≥ºÏóêÏÑú ÌïµÏã¨ Ï†ïÎ≥¥ Ï∂îÏ∂ú"""
        if not search_data or 'results' not in search_data:
            return "Ï†ïÎ≥¥ ÏóÜÏùå"
        
        results = search_data['results'][:3]  # ÏÉÅÏúÑ 3Í∞ú
        info_parts = []
        
        for r in results:
            title = r.get('title', '')
            content = r.get('content', '')[:250]  # 250ÏûêÎ°ú Ï¶ùÍ∞Ä
            if title or content:
                info_parts.append(f"{title}: {content}")
        
        return " | ".join(info_parts) if info_parts else "Ï†ïÎ≥¥ ÏóÜÏùå"
    
    async def _analyze_industry_dynamics(self, companies_data: Dict) -> Dict:
        """ÏÇ∞ÏóÖ Ï†ÑÏ≤¥ Ïó≠Ìïô Î∂ÑÏÑù"""
        self.logger.info("  üìä ÏÇ∞ÏóÖ Ïó≠Ìïô Î∂ÑÏÑù Ï§ë...")
        
        if not self.tavily_client:
            return self._get_fallback_industry_analysis()
        
        try:
            queries = [
                "electric vehicle industry competition market dynamics 2025",
                "EV market share leaders ranking 2025",
                "electric vehicle industry trends consolidation 2025"
            ]
            
            all_results = []
            for query in queries:
                search_results = await asyncio.to_thread(
                    self.tavily_client.search,
                    query=query,
                    max_results=3
                )
                all_results.extend(search_results.get('results', []))
            
            return {
                'queries': queries,
                'results': all_results,
                'analysis_date': datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"ÏÇ∞ÏóÖ Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return self._get_fallback_industry_analysis()
    
    async def _synthesize_company_insights(self, companies_data: Dict, industry_data: Dict) -> str:
        """Í∏∞ÏóÖ Î∂ÑÏÑù Ï¢ÖÌï©"""
        if not self.llm:
            return "Ï¢ÖÌï© Î∂ÑÏÑù Î∂àÍ∞Ä (LLM ÎØ∏ÏÑ§Ï†ï)"
        
        try:
            # ÏÉÅÏúÑ 5Í∞ú Í∏∞ÏóÖÎßå ÏöîÏïΩÏóê Ìè¨Ìï®
            top_companies = list(companies_data.keys())[:5]
            companies_summary = "\n".join([
                f"- {name}: {companies_data[name].get('llm_analysis', 'Î∂ÑÏÑù ÏóÜÏùå')[:300]}"
                for name in top_companies
            ])
            
            prompt = f"""Ï†ÑÍ∏∞Ï∞® Ï£ºÏöî Í∏∞ÏóÖÎì§({len(companies_data)}Í∞ú)Ïùò Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Ï¢ÖÌï©ÌïòÏÑ∏Ïöî:

Ï£ºÏöî Í∏∞ÏóÖ Î∂ÑÏÑù:
{companies_summary}

Îã§Ïùå ÌòïÏãùÏúºÎ°ú Ï¢ÖÌï© Ï†ïÎ¶¨Ìï¥Ï£ºÏÑ∏Ïöî:
1. ÏÇ∞ÏóÖ Î¶¨Îçî Î∞è ÏãúÏû• Íµ¨ÎèÑ (3-4Î¨∏Ïû•)
2. Í≤ΩÏüÅ Íµ¨ÎèÑ Î∞è Ï∞®Î≥ÑÌôî Ï†ÑÎûµ (3-4Î¨∏Ïû•)
3. Ï£ºÏöî Î≥ÄÌôî Î∞è Ìä∏Î†åÎìú (4-5Í∞ú bullet points)
4. Í∏∞Ïà† ÌòÅÏã† ÎèôÌñ• (2-3Î¨∏Ïû•)
5. Ìà¨Ïûê ÏãúÏÇ¨Ï†ê (3-4Î¨∏Ïû•)

ÌïúÍµ≠Ïñ¥Î°ú ÏûëÏÑ±ÌïòÏÑ∏Ïöî."""
            
            response = await self.llm.ainvoke(prompt)
            return response.content if hasattr(response, 'content') else str(response)
            
        except Exception as e:
            self.logger.error(f"Ï¢ÖÌï© Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return "Ï¢ÖÌï© Î∂ÑÏÑù Ï§ë Ïò§Î•ò Î∞úÏÉù"
    
    # Fallback Îç∞Ïù¥ÌÑ∞
    def _get_fallback_company_data(self, company: str) -> Dict:
        """Fallback Í∏∞ÏóÖ Îç∞Ïù¥ÌÑ∞"""
        fallback_data = {
            'Tesla': {
                'name': company,
                'strategy': 'FSD Î∞è ÏóêÎÑàÏßÄ ÌÜµÌï©, ÏàòÏßÅ ÌÜµÌï© Ï†ÑÎûµ',
                'production': 'Ïó∞Í∞Ñ 200ÎßåÎåÄ Î™©Ìëú, Í∏∞Í∞ÄÌå©ÌÜ†Î¶¨ ÌôïÏû•',
                'technology': '4680 Î∞∞ÌÑ∞Î¶¨, FSD (Full Self-Driving)',
                'market_position': 'ÌîÑÎ¶¨ÎØ∏ÏóÑ Ï†ÑÍ∏∞Ï∞® ÏãúÏû• Î¶¨Îçî',
                'llm_analysis': 'TeslaÎäî ÌîÑÎ¶¨ÎØ∏ÏóÑ Ï†ÑÍ∏∞Ï∞® ÏãúÏû•ÏùÑ ÏÑ†ÎèÑÌïòÎ©∞, ÏûêÏ≤¥ Î∞∞ÌÑ∞Î¶¨ ÏÉùÏÇ∞Í≥º ÏûêÏú®Ï£ºÌñâ Í∏∞Ïà†Î°ú Ï∞®Î≥ÑÌôîÌïòÍ≥† ÏûàÏäµÎãàÎã§.'
            },
            'BYD': {
                'name': company,
                'strategy': 'Î≤ÑÌã∞Ïª¨ ÌÜµÌï©, Îã§ÏñëÌïú Í∞ÄÍ≤©ÎåÄ ÎùºÏù∏ÏóÖ',
                'production': 'Ïó∞Í∞Ñ 300ÎßåÎåÄ Ïù¥ÏÉÅ, ÏÑ∏Í≥Ñ ÏµúÎåÄ EV ÏÉùÏÇ∞',
                'technology': 'Blade Î∞∞ÌÑ∞Î¶¨, e-Platform 3.0',
                'market_position': 'Í∏ÄÎ°úÎ≤å ÌåêÎß§ 1ÏúÑ',
                'llm_analysis': 'BYDÎäî ÏàòÏßÅ ÌÜµÌï©Îêú ÏÉùÏÇ∞ Ï≤¥Í≥ÑÏôÄ Blade Î∞∞ÌÑ∞Î¶¨Î°ú Í∞ÄÍ≤© Í≤ΩÏüÅÎ†•ÏùÑ ÌôïÎ≥¥ÌïòÏó¨ Í∏ÄÎ°úÎ≤å 1ÏúÑÎ•º Ï∞®ÏßÄÌñàÏäµÎãàÎã§.'
            },
            'Volkswagen': {
                'name': company,
                'strategy': 'ID ÏãúÎ¶¨Ï¶à ÌôïÎåÄ, Ï†ÑÎèôÌôî Ï†ÑÌôò Í∞ÄÏÜç',
                'production': 'Ïó∞Í∞Ñ 150ÎßåÎåÄ Î™©Ìëú',
                'technology': 'MEB ÌîåÎû´Ìèº, PowerCo Î∞∞ÌÑ∞Î¶¨',
                'market_position': 'Ïú†ÎüΩ ÏãúÏû• Í∞ïÏûê',
                'llm_analysis': 'VolkswagenÏùÄ MEB ÌîåÎû´ÌèºÏùÑ Í∏∞Î∞òÏúºÎ°ú Ï†Ñ Î∏åÎûúÎìúÏóê Ï†ÑÍ∏∞Ï∞®Î•º ÌôïÎåÄÌïòÎ©∞ Ïú†ÎüΩ ÏãúÏû•ÏùÑ Ï£ºÎèÑÌïòÍ≥† ÏûàÏäµÎãàÎã§.'
            }
        }
        
        return fallback_data.get(company, {
            'name': company,
            'strategy': f'{company} Ï†ÑÎûµ Ï†ïÎ≥¥ (Ïõπ Í≤ÄÏÉâ ÎØ∏ÏÇ¨Ïö©)',
            'production': f'{company} ÏÉùÏÇ∞ Ï†ïÎ≥¥ (Ïõπ Í≤ÄÏÉâ ÎØ∏ÏÇ¨Ïö©)',
            'technology': f'{company} Í∏∞Ïà† Ï†ïÎ≥¥ (Ïõπ Í≤ÄÏÉâ ÎØ∏ÏÇ¨Ïö©)',
            'market_position': 'Ï†ïÎ≥¥ ÏóÜÏùå',
            'note': 'Fallback Îç∞Ïù¥ÌÑ∞',
            'llm_analysis': f'{company}Îäî Ï†ÑÍ∏∞Ï∞® ÏãúÏû•Ïùò Ï£ºÏöî ÌîåÎ†àÏù¥Ïñ¥ÏûÖÎãàÎã§.'
        })
    
    def _get_fallback_industry_analysis(self) -> Dict:
        """Fallback ÏÇ∞ÏóÖ Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞"""
        return {
            'competition': 'ÏπòÏó¥Ìïú Í≤ΩÏüÅ Íµ¨ÎèÑ',
            'market_leaders': 'BYD, Tesla, Volkswagen, Hyundai, GM',
            'emerging_players': 'Rivian, Lucid, NIO, XPeng',
            'trends': 'Í∞ÄÍ≤© Í≤ΩÏüÅ Ïã¨Ìôî, Í∏∞Ïà† ÌòÅÏã† Í∞ÄÏÜçÌôî',
            'note': 'Fallback Îç∞Ïù¥ÌÑ∞ (Ïõπ Í≤ÄÏÉâ ÎØ∏ÏÇ¨Ïö©)'
        }